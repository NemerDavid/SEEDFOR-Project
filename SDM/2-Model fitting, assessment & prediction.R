library(tidyverse)
library(sf)
library(terra)
library(raster)
library(sp)
library(randomForest)
library(gbm)
library(mgcv)
library(precrec)
library(pROC)
library(caret)
library(tidymodels)
library(vip)

devtools::install_git("https://gitup.uni-potsdam.de/macroecology/mecofun.git")
library(mecofun)






#################################################################################################################
####################### A- Prepare and load the species occurrences & environmental data ######################## 

# Species occurrences data
Presence_Absence<- readRDS("C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Data/Presence_Absence.rds") 
# Environmental data
Current_climate <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/Chelsa/Chelsa_preparedData/Current_climate.rds')# Current
Future_climate <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/Chelsa/Chelsa_preparedData/Future_climate.rds')# Future

Current_climate<-terra::unwrap(Current_climate)
Future_climate<-terra::unwrap(Future_climate)


head(Presence_Absence)
Species_pts <- st_as_sf(Presence_Absence, 
                        coords = c("longitude", "latitude")) 
st_crs(Species_pts) <- 4326


### Combine presence absence data with bioclim data
Species_bio <- terra::extract(Current_climate, vect(Species_pts)) %>%
  bind_cols(Species_pts) %>%
  as.data.frame()
names(Species_bio)

##################################
### Filter for the desired species
##################################
### 1. Fagus sylvatica ###
#=======================#
Fagus_sylvatica<-subset(Species_bio,species=="Fagus sylvatica")



## split the data intro training and test set ##
set.seed(333)

# Create the balanced data split
Fagus_sylvatica<-na.omit(Fagus_sylvatica)
Fagus_split <- initial_split(Fagus_sylvatica,prop =0.75,strata = presence_absence)
# Extract the training and test set
Fagus_train <- training(Fagus_split)
Fagus_test  <- testing(Fagus_split)





##############################################################################################################################
########################################### B- Model tuning, building & assessment ########################################### 


################################################
############### 1- Random Forest ###############
################################################


#---------------------- 1a - Tuning ---------------------# 

# Define the grid of hyperparameters to be tuned
tunegrid <- expand.grid(mtry= c(2,3,4,5,6,7), # number of predictor variables to sample at each split
                        splitrule = c("variance"), # splitting rule "gini" for classification and "variance" for regression
                        min.node.size = c(10,15,20,25,35)) # minimum size of terminal nodes

# Setting min.node.size to a larger value can help prevent overfitting
# by limiting the complexity of the trees. If the value is too small, 
# the trees might become overly complex and capture noise in the data, 
# leading to poor generalization performance on unseen data.
set.seed(333)

## fit the model to search for the best parameters ##
rf_model_Fagus <- train(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Fagus_train, 
  method = "ranger",
  num.trees=500,
  tuneGrid=tunegrid,
  metric='RMSE',
  trControl = trainControl(
    method = "cv",
    number = 5,
    allowParallel = TRUE,
    verboseIter = TRUE,savePredictions = TRUE))

## Display the tuning results and select the best tune
plot(rf_model)
rf_model$bestTune

#---------------------- 1b - re-run the model with the best tune values ----------------------#

##!!!!!!!!!!!! Note before running this code, this operation might take hours,!!!!!!!!!!!!! ###
## If you don't want run it, you can simply load the saved results generated by random forest algorithm bellow ##

set.seed(333)
rf_Fagus<-randomForest(presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
                       data = Fagus_train, ntree=500,
                       nodesize=20,
                       mtry=2) 

# Load the results of the random forest algorithm (rf)
rf_Fagus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Fagus Sylvatica/random_forest_model.rds')


#---------------------- 1c - Model assessment ----------------------#
# Predict on test set
(perf_rf_Fagus <- evalSDM(Fagus_test$presence_absence, predict(rf_Fagus, Fagus_test, type='response')))


## Partial_response and variables importance ##
vip::vip(rf_Fagus)

head(Fagus_train)
Predictors_Fagus<-Fagus_train[,2:8]

par(mfrow=c(2,4))
partial_response(rf_Fagus, predictors = Predictors_Fagus, main='Random Forest')


#----------------------1d - Predictions for the current and future climate ----------------------#

rf_cur <- predict(object = Current_climate,
                  model = rf_Fagus,
                  type = "response",
                  na.rm = TRUE)

rf_proj <- predict(object = Future_climate, 
                   model = rf_Fagus, 
                   type = "response",
                   na.rm = TRUE)


rf_chg <- c(rf_cur, rf_proj)
names(rf_chg) <- c("Current","Future")


rf_clas <- ifel(rf_chg > perf_rf_Fagus$thresh, 1, 0)

plot(rf_clas,main = "Fagus sylvatica - Random Forest")
plot(rf_cur_clas <- ifel(rf_cur > perf_rf_Fagus$thresh, 1, 0),main="Fagus sylvatica current distribution - RF")
plot(rf_proj_clas <- ifel(rf_proj > perf_rf_Fagus$thresh, 1, 0),main="Fagus sylvatica future distribution - RF")



#######################################################
############### 2- Gradient boost model ###############
#######################################################

#---------------------- 2a - Tuning ---------------------# 
gbm_grid = expand.grid(interaction.depth = c(1, 2, 3),
                       n.trees = 500,
                       shrinkage = c(0.1, 0.3),
                       n.minobsinnode = 20,
                       bag.fraction)

## fit the model to search for the best parameters ##
set.seed(333)
gbm_mod_Fagus<-train(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Fagus_train,
  trControl = trainControl(method = "cv", number = 5,allowParallel = TRUE,verboseIter = TRUE),
  method = "gbm",
  tuneGrid = gbm_grid
)

## Display the tuning results and select the best tune
plot(gbm_mod_Fagus)
gbm_mod_Fagus$results
gbm_mod_Fagus$bestTune


#---------------------- 2b - re-run the model with the best tune values ----------------------#

gbm_mod2_Fagus<-gbm(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Fagus_train,
  distribution = "bernoulli",
  n.trees = 500,
  interaction.depth = 3,
  n.minobsinnode = 20,
  shrinkage = 0.3,
  bag.fraction = 0.5,
  keep.data = TRUE,
  verbose = TRUE,
  n.cores = 5
)

# Load the saved `gbm_mod2` results
gbm_mod2_Fagus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Fagus Sylvatica/gbm_mod2.rds')



#---------------------- 2c - Model assessment ----------------------#
# Predict on test set
(perf_gbm_Fagus <- evalSDM(Fagus_test$presence_absence, predict(gbm_mod2_Fagus, Fagus_test, type='response')))

# Compute variable importance
vip::vip(gbm_mod2_Fagus) 

## partial_response ##
partial_response(gbm_mod2_Fagus, predictors = Predictors_Fagus, main='GBM')


#----------------------2d - Predictions for the current and future climate ----------------------#

gbm_cur <- predict(object = Current_climate,
                   model = gbm_mod2_Fagus,
                   type = "response",
                   na.rm = TRUE)

gbm_proj <- predict(object = Future_climate, 
                    model = gbm_mod2_Fagus, 
                    type = "response", 
                    na.rm = TRUE)

gbm_chg <- c(gbm_cur, gbm_proj)
names(gbm_chg) <- c("Current", "Future")
summary(gbm_chg)

gbm_clas <- ifel(gbm_chg > perf_gbm_Fagus$thresh, 1, 0)
summary(gbm_clas)

plot(gbm_clas)

plot(gbm_clas,main = "Fagus sylvatica - GBM")


#####################################################################
############### 3- Generalized additive models (GAMS) ###############
#####################################################################

# calculating weights (equal weights)
prNum_Fagus <- as.numeric(table(Fagus_train$presence_absence)["1"]) # number of presences
bgNum_Fagus <- as.numeric(table(Fagus_train$presence_absence)["0"]) # number of absences
wt_Fagus <- ifelse(Fagus_train$presence_absence == 1, 1, prNum / bgNum)



#---------------------- 3a - Tuning ---------------------# 

### Creating a tune grid to choose  the best K (knots value) ###
# Define the response variable
response_var <- "presence_absence"
# Set up the grid of k values to test
k_values <- c(2:10) # adjust as needed
# Create an empty vector to store results
K_scores <- numeric(length(k_values))

# Set seed for reproducibility
set.seed(333)

# Perform a loop to test for each k value
for (i in seq_along(k_values)) {
  k <- k_values[i]
  # Construct the formula
  formula <- as.formula(paste(response_var, "~",
                              paste0("s(bio1, k=", k, ") + s(bio12, k=", k, ") + s(bio5, k=", k, ") + s(bio6, k=", k, ") + s(bio16, k=", k, ") + s(bio17, k=", k, ") + s(pH, k=", k, ")")))
  
  # fitt the model for each K value
  cv_model_Fagus <- gam(formula = formula,
                        data = Fagus_train,
                        family = binomial(link = "logit"),
                        weights = wt_Fagus,
                        method = "REML")
  # Store K scores
  K_scores[i] <- cv_model_Fagus$sp
}

# Find the index of the best k value
best_k_index <- which.min(K_scores)
# Select the best k value
best_k <- k_values[best_k_index]


#---------------------- 3b - re-run the model with the best tune values ----------------------#
gam_model_Fagus <- gam(formula = as.formula(paste(response_var, "~",
                                                  paste0("s(bio1, k=", best_k, ") + s(bio12, k=", best_k, ") + s(bio5, k=", best_k, ") + s(bio6, k=", best_k, ") + s(bio16, k=", best_k, ") + s(bio17, k=", best_k, ") + s(pH, k=", best_k, ")"))),
                       data = Fagus_train,
                       family = binomial(link = "logit"),
                       weights = wt_Fagus,
                       method = "REML")

# Load the saved `gam_model` results
gam_model_Fagus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Fagus Sylvatica/gam_model.rds')



#---------------------- 3c - Model assessment ----------------------#
# Performance measures
(perf_gam_Fagus <- evalSDM(Fagus_test$presence_absence, predict(gam_model_Fagus, Fagus_test, type='response'), thresh.method = "MaxSens+Spec"))




## partial_response ##
plot(gam_model_Fagus, pages = 1, rug = TRUE, shade = TRUE)
partial_response(gam_model_Fagus, predictors = Predictors_Fagus, main='GAM')

plot(gam_model_Fagus, select = 3, shade = TRUE)


#----------------------3d - Predictions for the current and future climate ----------------------#
gam_cur <- predict(object = Current_climate,
                   model = gam_Fagus,
                   type = "response",
                   na.rm = TRUE)

gam_proj <- predict(object = Future_climate, 
                    model = gam_Fagus, 
                    type = "response", 
                    na.rm = TRUE)

gam_chg <- c(gam_cur, gam_proj)
names(gam_chg) <- c("Current", "Future")

plot(gam_chg)
gam_clas <- ifel(gam_chg > perf_gam_Fagus$thresh, 1, 0)
summary(gam_clas)

plot(gam_clas)



#####################################################################
###############  4- Generalized linear models (GLMS)  ###############
#####################################################################
#----- 4a - Model fitting -----#

# calculating weights (equal weights)
prNum_Fagus <- as.numeric(table(Fagus_train$presence_absence)["1"]) # number of presences
bgNum_Fagus <- as.numeric(table(Fagus_train$presence_absence)["0"]) # number of absences
wt_Fagus <- ifelse(Fagus_train$presence_absence == 1, 1, prNum / bgNum)

glm_model_Fagus <- glm(presence_absence ~bio1 + bio5 + bio6 + bio12 + bio16 + bio17 + pH, data = Fagus_train,
                       weights = wt_Fagus, family = binomial(link = "logit"))


#----- 4b- Performance measures -----#
(perf_glm_Fagus <- evalSDM(Fagus_test$presence_absence, predict(glm_model_Fagus, Fagus_test, type='response'), thresh.method = "MaxSens+Spec"))

vip(glm_model_Fagus)
partial_response(glm_model_Fagus, predictors = Predictors_Fagus, main='glm')

#----------------------4c - Predictions for the current and future climate ----------------------#
#Current climate
glm_cur <- predict(object = Current_climate,
                   model = glm_model_Fagus,
                   type = "response",
                   na.rm = TRUE)
#Current climate
glm_proj <- predict(object = Future_climate, 
                    model = glm_model_Fagus, 
                    type = "response", 
                    na.rm = TRUE)

glm_chg <- c(glm_cur, glm_proj)
names(glm_chg) <- c("Current", "Future")

glm_clas <- ifel(glm_chg > perf_glm_Fagus$thresh, 1, 0)
summary(glm_clas)

plot(glm_clas)




######################################################
###############  5- Model comparison   ###############
######################################################
# Below are the algorithms we fitted and the predictions we made on test data to asses our models performances
rf_Fagus
gbm_mod2_Fagus
gam_model_Fagus
glm_model_Fagus

# Predict on test set
(perf_glm_Fagus <- evalSDM(Fagus_test$presence_absence, predict(glm_model_Fagus, Fagus_test, type='response')))
(perf_gam_Fagus <- evalSDM(Fagus_test$presence_absence, predict(gam_model_Fagus, Fagus_test, type='response')))
(perf_rf_Fagus <- evalSDM(Fagus_test$presence_absence, predict(rf_Fagus, Fagus_test, type='response')))
(perf_gbm_Fagus <- evalSDM(Fagus_test$presence_absence, predict(gbm_mod2_Fagus, Fagus_test, type='response')))


#------  5a - Combine the performances of our models and compare them ------#
(comp_perf_Fagus <- rbind(glm_pred = perf_glm_Fagus,gam_pred=perf_gam_Fagus,rf_pred = perf_rf_Fagus, gbm_pred = perf_gbm_Fagus))
# We add a column containing the names of the algorithm
comp_perf_Fagus <- data.frame(alg=row.names(comp_perf_Fagus),comp_perf_Fagus)

#------5b -combine all the Predictions we made on the test set ------#
pred_testdata_Fagus <- data.frame(
  glm_pred = predict(glm_model_Fagus, Fagus_test, type='response'),
  gam_pred=predict(gam_model_Fagus, Fagus_test, type='response'),
  rf_pred = predict(rf_Fagus, Fagus_test, type='response'),
  gbm_pred = predict(gbm_mod2_Fagus, Fagus_test, type='response'))

# Add it to the test set data
pred_testdata_Fagus <- cbind(pred_testdata_Fagus, Fagus_test)

#------ 5c - calculate the confusion matrix for each model and check model accuracy ------#
# Initialize an empty list to store confusion matrices
confusion_matrices_Fagus <- list()

# Iterate over the columns of pred_testdata_Fagus
for (col_name in names(pred_testdata_Fagus)) {
  # Skip columns that are not predictions
  if (!(col_name %in% c("glm_pred","gam_pred", "rf_pred", "gbm_pred"))) {
    next
  }
  
  # Calculate the confusion matrix for each prediction column
  predictions2 <- pred_testdata_Fagus
  threshold <- comp_perf_Fagus$thresh[match(col_name, comp_perf_Fagus$alg)]
  
  predictions2$pred <- ifelse(predictions2[[col_name]] > threshold, 1, 0)
  predictions2$pred <- as.factor(predictions2$pred)
  predictions2$presence_absence <- as.factor(predictions2$presence_absence)
  
  # Evaluate model performance on the test set
  confusion_matrices_Fagus[[col_name]] <- confusionMatrix(predictions2$pred, predictions2$presence_absence)
}

# Access confusion matrices for each prediction
# Example for accessing confusion matrix for glm_pred
confusion_matrices_Fagus$glm_pred$overall[1]
confusion_matrices_Fagus$gam_pred$overall[1]
confusion_matrices_Fagus$rf_pred$overall[1]
confusion_matrices_Fagus$gbm_pred$overall[1]



#----- 5d - plot AUC ROC -----#
head(pred_testdata_Fagus)
roc_curve_glm<- roc(pred_testdata_Fagus$presence_absence, pred_testdata_Fagus$glm_pred)
roc_curve_gam<- roc(pred_testdata_Fagus$presence_absence, pred_testdata_Fagus$gam_pred)
roc_curve_rf<- roc(pred_testdata_Fagus$presence_absence, pred_testdata_Fagus$rf_pred)
roc_curve_gbm<- roc(pred_testdata_Fagus$presence_absence, pred_testdata_Fagus$gbm_pred)

# Combine TPR and FPR into a data frame
roc_curve_df <- rbind(
  data.frame(TPR = roc_curve_glm$sensitivities, FPR = 1 - roc_curve_glm$specificities, alg = "glm"),
  data.frame(TPR = roc_curve_gam$sensitivities, FPR = 1 - roc_curve_gam$specificities, alg = "gam"),
  data.frame(TPR = roc_curve_rf$sensitivities, FPR = 1 - roc_curve_rf$specificities, alg = "rf"),
  data.frame(TPR = roc_curve_gbm$sensitivities, FPR = 1 - roc_curve_gbm$specificities, alg = "gbm")
)

# Create a data frame for AUC values
auc_df <- data.frame(alg = c("glm", "gam", "rf", "gbm"),
                     AUC = c(roc_curve_glm$auc, roc_curve_gam$auc, roc_curve_rf$auc, roc_curve_gbm$auc))

# Plot ROC curves
ggplot(roc_curve_df, aes(x = FPR, y = TPR, color = alg)) +
  geom_line() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  labs(title = "ROC-AUC",
       x = "False Positive Rate (1 - Specificity)",
       y = "True Positive Rate (Sensitivity)",
       color = "Algorithm") +
  scale_x_continuous(expand = c(0.005, 0)) +
  scale_y_continuous(expand = c(0.005, 0)) +
  coord_fixed() +
  theme_bw() +
  facet_wrap(~ alg) +
  geom_text(data = auc_df, aes(x = 0.78, y = 0.2, label = paste0("AUC = ", round(AUC, 2))), size = 4, color = "black", fontface = "bold") + 
  theme(panel.spacing = unit(0.9, "cm", data = NULL))



#############################################
###############  6- Ensemble  ###############
#############################################


#------ 6a Predict the ensemble on the test data to get the thresholds and asses the performance of the ensemble ------#

crosspred_ens_Fagus <- data.frame(glm_pred=pred_testdata_Fagus$glm_pred,
                                  gam_pred=pred_testdata_Fagus$gam_pred,
                                  rf_pred=pred_testdata_Fagus$rf_pred ,
                                  gbm_pred=pred_testdata_Fagus$gbm_pred)

head(crosspred_ens_Fagus)
### Preparing the data for ensembles predictions ###
# Mean of probabilities
mean_prob_Fagus <- rowMeans(crosspred_ens_Fagus)
# Median of probabilities
median_prob_Fagus <- apply(crosspred_ens_Fagus, 1, median)
# Weighted mean of probabilities, weighted by TSS 
# (Make sure that order of models is the same in df for predictions and performance!!)
wmean_prob_Fagus <- apply(crosspred_ens_Fagus, 1, function(row) {
  weighted.mean(row, w = comp_perf_Fagus[row.names(comp_perf_Fagus), 'TSS'])
})

env_ensemble_Fagus <- data.frame(mean_prob_Fagus,median_prob_Fagus,wmean_prob_Fagus)

# performance measures for "mean of probabilities"
(perf_mean_prob_Fagus <- evalSDM(Fagus_test$presence_absence, mean_prob_Fagus))
# performance measures for "median of probabilities":
(perf_median_prob_Fagus <- evalSDM(Fagus_test$presence_absence, median_prob_Fagus))
# performance measures for "weighted mean of probabilities":
(perf_wmean_prob_Fagus <- evalSDM(Fagus_test$presence_absence, wmean_prob_Fagus))

# Compare performance measures:
(ens_perf_Fagus <- rbind(mean_prob = perf_mean_prob_Fagus,
                         median_prob = perf_median_prob_Fagus, 
                         wmean_prob = perf_wmean_prob_Fagus))
# We add a column containing the names of the algorithm
ens_perf_Fagus <- data.frame(method=row.names(ens_perf_Fagus),ens_perf_Fagus)


#------ 6b Predict the ensemble to the current & future climate ------#

##################
# current climate:
##################
Current_raster<-stack(Current_climate)

bio_curr_df_Fagus <- data.frame(rasterToPoints(Current_raster))
bio_curr_df_Fagus
bio_curr_df_Fagus<-na.omit(bio_curr_df_Fagus)

bio_curr_df_Fagus$pred_glm <- mecofun::predictSDM(glm_model_Fagus, bio_curr_df_Fagus)
bio_curr_df_Fagus$pred_gam <- mecofun::predictSDM(gam_model_Fagus, bio_curr_df_Fagus)
bio_curr_df_Fagus$pred_rf <- mecofun::predictSDM(rf_Fagus, bio_curr_df_Fagus)
bio_curr_df_Fagus$pred_gbm <- mecofun::predictSDM(gbm_mod2_Fagus,bio_curr_df_Fagus)
bio_curr_df_Fagus$pred_ens_mean <- apply(bio_curr_df_Fagus[,c(10:12)],1,mean)
bio_curr_df_Fagus$pred_ens_median <- apply(bio_curr_df_Fagus[,c(10:12)],1,median)
bio_curr_df_Fagus$pred_ens_wmean <- apply(bio_curr_df_Fagus[,c(10:13)],1, function(row) {
  weighted.mean(row, w = comp_perf_Fagus[row.names(comp_perf_Fagus), 'TSS'])
})
head(bio_curr_df_Fagus)

# Make binary predictions:
bio_curr_df_Fagus$bin_glm <- ifelse(bio_curr_df_Fagus$pred_glm > perf_glm_Fagus$thresh, 1, 0)
bio_curr_df_Fagus$bin_gam<- ifelse(bio_curr_df_Fagus$pred_gam > perf_gam_Fagus$thresh, 1, 0)
bio_curr_df_Fagus$bin_rf <- ifelse(bio_curr_df_Fagus$pred_rf > perf_rf_Fagus$thresh, 1, 0)
bio_curr_df_Fagus$bin_gbm <- ifelse(bio_curr_df_Fagus$pred_gbm > perf_gbm_Fagus$thresh, 1, 0)
bio_curr_df_Fagus$bin_ens_mean <- ifelse(bio_curr_df_Fagus$pred_ens_mean > ens_perf_Fagus[1,]$thresh, 1, 0)
bio_curr_df_Fagus$bin_ens_median <- ifelse(bio_curr_df_Fagus$pred_ens_median > ens_perf_Fagus[2,]$thresh, 1, 0)
bio_curr_df_Fagus$bin_ens_wmean <- ifelse(bio_curr_df_Fagus$pred_ens_wmean > ens_perf_Fagus[3,]$thresh, 1, 0)

head(bio_curr_df_Fagus)
# Make raster stack of predictions:
pred_curr_Fagus <- rasterFromXYZ(bio_curr_df_Fagus[,-c(3:9)])


##### Ensemble predictions mapping #####

plot(pred_curr_Fagus)

par(mfrow=c(2,5))

## Prob ##
plot(pred_curr_Fagus$pred_glm)
plot(pred_curr_Fagus$pred_gam)
plot(pred_curr_Fagus$pred_rf)
plot(pred_curr_Fagus$pred_gbm)
plot(pred_curr_Fagus$pred_ens_mean)

## Binary ##
plot(pred_curr_Fagus$bin_glm)
plot(pred_curr_Fagus$bin_gam)
plot(pred_curr_Fagus$bin_rf)
plot(pred_curr_Fagus$bin_gbm)
plot(pred_curr_Fagus$bin_ens_mean)

#################
# future climate:
#################
Future_raster<-stack(Future_climate)
bio_fut_df_Fagus <- data.frame(rasterToPoints(Future_raster))
bio_fut_df_Fagus<-na.omit(bio_fut_df_Fagus)


bio_fut_df_Fagus$pred_glm <- mecofun::predictSDM(glm_model_Fagus, bio_fut_df_Fagus)
bio_fut_df_Fagus$pred_gam <- mecofun::predictSDM(gam_model_Fagus, bio_fut_df_Fagus)
bio_fut_df_Fagus$pred_rf <- mecofun::predictSDM(rf_Fagus, bio_fut_df_Fagus)
bio_fut_df_Fagus$pred_gbm <- mecofun::predictSDM(gbm_mod2_Fagus,bio_fut_df_Fagus)
bio_fut_df_Fagus$pred_ens_mean <- apply(bio_fut_df_Fagus[,c(10:12)],1,mean)
bio_fut_df_Fagus$pred_ens_median <- apply(bio_fut_df_Fagus[,c(10:12)],1,median)
bio_fut_df_Fagus$pred_ens_wmean <- apply(bio_fut_df_Fagus[,c(10:13)],1, function(row) {
  weighted.mean(row, w = comp_perf_Fagus[row.names(comp_perf_Fagus), 'TSS'])
})
head(bio_fut_df_Fagus)

# Make binary predictions:
bio_fut_df_Fagus$bin_glm <- ifelse(bio_fut_df_Fagus$pred_glm > perf_glm_Fagus$thresh, 1, 0)
bio_fut_df_Fagus$bin_gam<- ifelse(bio_fut_df_Fagus$pred_gam > perf_gam_Fagus$thresh, 1, 0)
bio_fut_df_Fagus$bin_rf <- ifelse(bio_fut_df_Fagus$pred_rf > perf_rf_Fagus$thresh, 1, 0)
bio_fut_df_Fagus$bin_gbm <- ifelse(bio_fut_df_Fagus$pred_gbm > perf_gbm_Fagus$thresh, 1, 0)
bio_fut_df_Fagus$bin_ens_mean <- ifelse(bio_fut_df_Fagus$pred_ens_mean > ens_perf_Fagus[1,]$thresh, 1, 0)
bio_fut_df_Fagus$bin_ens_median <- ifelse(bio_fut_df_Fagus$pred_ens_median > ens_perf_Fagus[2,]$thresh, 1, 0)
bio_fut_df_Fagus$bin_ens_wmean <- ifelse(bio_fut_df_Fagus$pred_ens_wmean > ens_perf_Fagus[3,]$thresh, 1, 0)

head(bio_fut_df_Fagus)
# Make raster stack of predictions:
pred_fut_Fagus <- rasterFromXYZ(bio_fut_df_Fagus[,-c(3:9)])

##### Ensemble predictions mapping #####

plot(pred_fut_Fagus)

par(mfrow=c(2,5))
## Prob ##
plot(pred_fut_Fagus$pred_glm)
plot(pred_fut_Fagus$pred_gam)
plot(pred_fut_Fagus$pred_rf)
plot(pred_fut_Fagus$pred_gbm)
plot(pred_fut_Fagus$pred_ens_mean)

## Binary ##
plot(pred_fut_Fagus$bin_glm)
plot(pred_fut_Fagus$bin_gam)
plot(pred_fut_Fagus$bin_rf)
plot(pred_fut_Fagus$bin_gbm)
plot(pred_fut_Fagus$bin_ens_mean)












#### repeat the same thing for Quercus pubescens 


##################################
### Filter for the desired species
##################################
### 2. Quercus pubescens ###
#==========================#
Quercus_pubescens <-subset(Species_bio,species=="Quercus pubescens")



## split the data intro training and test set ##
set.seed(333)

# Create the balanced data split
Quercus_pubescens<-na.omit(Quercus_pubescens)
Quercus_split <- initial_split(Quercus_pubescens,prop =0.75,strata = presence_absence)
# Extract the training and test set
Quercus_train <- training(Quercus_split)
Quercus_test  <- testing(Quercus_split)

head(Quercus_train)




##############################################################################################################################
########################################### B- Model tuning, building & assessment ########################################### 


################################################
############### 1- Random Forest ###############
################################################


#---------------------- 1a - Tuning ---------------------# 

# Define the grid of hyperparameters to be tuned
tunegrid <- expand.grid(mtry= c(2,3,4,5,6,7), # number of predictor variables to sample at each split
                        splitrule = c("variance"), # splitting rule "gini" for classification and "variance" for regression
                        min.node.size = c(10,15,20,25,35)) # minimum size of terminal nodes

# Setting min.node.size to a larger value can help prevent overfitting
# by limiting the complexity of the trees. If the value is too small, 
# the trees might become overly complex and capture noise in the data, 
# leading to poor generalization performance on unseen data.
set.seed(333)


# You can load the results of of the tuned model
rf_model_tuning <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Quercus pubescens/rf_model_tuning.rds')
rf_model_tuning$bestTune

## fit the model to search for the best parameters ##
rf_model_Quercus <- train(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Quercus_train, 
  method = "ranger",
  num.trees=500,
  tuneGrid=tunegrid,
  metric='RMSE',
  trControl = trainControl(
    method = "cv",
    number = 5,
    allowParallel = TRUE,
    verboseIter = TRUE,savePredictions = TRUE))

## Display the tuning results and select the best tune
plot(rf_model_Quercus)
rf_model_Quercus$bestTune





#---------------------- 1b - re-run the model with the best tune values ----------------------#

##!!!!!!!!!!!! Note before running this code, this operation might take hours,!!!!!!!!!!!!! ###
## If you don't want run it, you can simply load the saved results generated by random forest algorithm bellow ##

set.seed(333)
rf_Quercus<-randomForest(presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
                         data = Quercus_train, ntree=500,
                         nodesize=10,
                         mtry=2) 


# Load the results of the random forest algorithm (rf)
rf_Quercus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Quercus pubescens/rf_Quercus.rds')


#---------------------- 1c - Model assessment ----------------------#
# Predict on test set
(perf_rf_Quercus <- evalSDM(Quercus_test$presence_absence, predict(rf_Quercus, Quercus_test, type='response')))


## Partial_response and variables importance ##
vip::vip(rf_Quercus)

Predictors_Quercus<-Quercus_train[,2:8]

par(mfrow=c(2,4))
partial_response(rf_Quercus, predictors = Predictors_Quercus, main='Random Forest')


#----------------------1d - Predictions for the current and future climate ----------------------#

rf_cur_ <- predict(object = Current_climate,
                   model = rf_Quercus,
                   type = "response",
                   na.rm = TRUE)

rf_proj <- predict(object = Future_climate, 
                   model = rf_Quercus, 
                   type = "response",
                   na.rm = TRUE)


rf_chg <- c(rf_cur, rf_proj)
names(rf_chg) <- c("Current","Future")


rf_clas <- ifel(rf_chg > perf_rf$thresh, 1, 0)

plot(rf_clas,main = "Quercus - Random Forest")
plot(rf_cur_clas <- ifel(rf_cur > perf_rf$thresh, 1, 0),main="Quercus current distribution - RF")
plot(rf_proj_clas <- ifel(rf_proj > perf_rf$thresh, 1, 0),main="Quercus future distribution - RF")



#######################################################
############### 2- Gradient boost model ###############
#######################################################

#---------------------- 2a - Tuning ---------------------# 
gbm_grid = expand.grid(interaction.depth = c(1, 2, 3),
                       n.trees = 500,
                       shrinkage = c(0.1, 0.3),
                       n.minobsinnode = 20)


## fit the model to search for the best parameters ##
set.seed(333)
gbm_mod_Quercus<-train(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Quercus_train,
  trControl = trainControl(method = "cv", number = 5,allowParallel = TRUE,verboseIter = TRUE),
  method = "gbm",
  tuneGrid = gbm_grid
)

## Display the tuning results and select the best tune
plot(gbm_mod_Quercus)
gbm_mod_Quercus$results
gbm_mod_Quercus$bestTune


# You can load the results of of the tuned model
gbm_model_tuning <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Quercus pubescens/gbm_mod_Quercus_tuning.rds')
gbm_model_tuning$bestTune



#---------------------- 2b - re-run the model with the best tune values ----------------------#

gbm_mod2_Quercus<-gbm(
  presence_absence~bio1+bio5+bio6+bio12+bio16+bio17+pH,
  data = Quercus_train,
  distribution = "bernoulli",
  n.trees = 500,
  interaction.depth = 3,
  n.minobsinnode = 20,
  shrinkage = 0.3,
  bag.fraction = 0.5,
  keep.data = TRUE,
  verbose = TRUE,
  n.cores = 5
)

# Load the results of the gbm algorithm (
gbm_mod2_Quercus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Quercus pubescens/gbm_mod2_Quercus.rds')




#---------------------- 2c - Model assessment ----------------------#
# Predict on test set
(perf_gbm_Quercus <- evalSDM(Quercus_test$presence_absence, predict(gbm_mod2_Quercus, Quercus_test, type='response')))


# Compute variable importance
vip::vip(gbm_mod2_Quercus) 

## partial_response ##
partial_response(gbm_mod2_Quercus, predictors = Predictors_Quercus, main='GBM')


#----------------------2d - Predictions for the current and future climate ----------------------#

gbm_cur <- predict(object = Current_climate,
                   model = gbm_mod2_Quercus,
                   type = "response",
                   na.rm = TRUE)

gbm_proj <- predict(object = Future_climate, 
                    model = gbm_mod2_Quercus, 
                    type = "response", 
                    na.rm = TRUE)

gbm_chg <- c(gbm_cur, gbm_proj)
names(gbm_chg) <- c("Current", "Future")
summary(gbm_chg)

gbm_clas <- ifel(gbm_chg > perf_gbm$thresh, 1, 0)
summary(gbm_clas)

plot(gbm_clas)

plot(gbm_clas,main = "Fagus sylvatica - GBM")


#####################################################################
############### 3- Generalized additive models (GAMS) ###############
#####################################################################

# calculating weights (equal weights)
prNum_Quercus <- as.numeric(table(Quercus_train$presence_absence)["1"]) # number of presences
bgNum_Quercus <- as.numeric(table(Quercus_train$presence_absence)["0"]) # number of absences
wt_Quercus <- ifelse(Quercus_train$presence_absence == 1, 1, prNum / bgNum)



#---------------------- 3a - Tuning ---------------------# 

### Creating a tune grid to choose  the best K (knots value) ###
# Define the response variable
response_var <- "presence_absence"
# Set up the grid of k values to test
k_values <- c(2:10) # adjust as needed
# Create an empty vector to store results
K_scores <- numeric(length(k_values))

# Set seed for reproducibility
set.seed(333)

# Perform a loop to test for each k value
for (i in seq_along(k_values)) {
  k <- k_values[i]
  # Construct the formula
  formula <- as.formula(paste(response_var, "~",
                              paste0("s(bio1, k=", k, ") + s(bio12, k=", k, ") + s(bio5, k=", k, ") + s(bio6, k=", k, ") + s(bio16, k=", k, ") + s(bio17, k=", k, ") + s(pH, k=", k, ")")))
  
  # fitt the model for each K value
  cv_model_Quercus <- gam(formula = formula,
                          data = Quercus_train,
                          family = binomial(link = "logit"),
                          weights = wt_Quercus,
                          method = "REML")
  # Store K scores
  K_scores[i] <- cv_model_Quercus$sp
}

# Find the index of the best k value
best_k_index <- which.min(K_scores)
# Select the best k value
best_k <- k_values[best_k_index]


#---------------------- 3b - re-run the model with the best tune values ----------------------#
gam_model_Quercus <- gam(formula = as.formula(paste(response_var, "~",
                                                    paste0("s(bio1, k=", best_k, ") + s(bio12, k=", best_k, ") + s(bio5, k=", best_k, ") + s(bio6, k=", best_k, ") + s(bio16, k=", best_k, ") + s(bio17, k=", best_k, ") + s(pH, k=", best_k, ")"))),
                         data = Quercus_train,
                         family = binomial(link = "logit"),
                         weights = wt_Quercus,
                         method = "REML")


# Load the saved `gam_model` results
gam_model_Quercus <- readRDS('C:/Users/nemer/Project/SEEDFOR-Project/SDM/SDM_Mod_results/Quercus pubescens/gam_model_Quercus.rds')






#---------------------- 3c - Model assessment ----------------------#
# Performance measures
(perf_gam_Quercus <- evalSDM(Quercus_test$presence_absence, predict(gam_model_Quercus, Quercus_test, type='response'), thresh.method = "MaxSens+Spec"))




## partial_response ##
plot(gam_model_Quercus, pages = 1, rug = TRUE, shade = TRUE)
partial_response(gam_model_Quercus, predictors = Predictors_Quercus, main='GAM')

plot(gam_model_Quercus, select = 3, shade = TRUE)


#----------------------3d - Predictions for the current and future climate ----------------------#
gam_cur <- predict(object = Current_climate,
                   model = gam_model_Quercus,
                   type = "response",
                   na.rm = TRUE)

gam_proj <- predict(object = Future_climate, 
                    model = gam_model_Quercus, 
                    type = "response", 
                    na.rm = TRUE)

gam_chg <- c(gam_cur, gam_proj)
names(gam_chg) <- c("Current", "Future")

plot(gam_chg)
gam_clas <- ifel(gam_chg > perf_gam$thresh, 1, 0)
summary(gam_clas)

plot(gam_clas)



#####################################################################
###############  4- Generalized linear models (GLMS)  ###############
#####################################################################
#----- 4a - Model fitting -----#
# calculating weights (equal weights)
prNum_Quercus <- as.numeric(table(Quercus_train$presence_absence)["1"]) # number of presences
bgNum_Quercus <- as.numeric(table(Quercus_train$presence_absence)["0"]) # number of absences
wt_Quercus <- ifelse(Quercus_train$presence_absence == 1, 1, prNum / bgNum)

glm_model_Quercus <- glm(presence_absence ~bio1 + bio5 + bio6 + bio12 + bio16 + bio17 + pH, data = Quercus_train,
                         weights = wt_Quercus, family = binomial(link = "logit"))


#----- 4b- Performance measures -----#
(perf_glm_Quercus <- evalSDM(Quercus_test$presence_absence, predict(glm_model_Quercus, Quercus_test, type='response'), thresh.method = "MaxSens+Spec"))


vip(glm_model_Quercus)
partial_response(glm_model_Quercus, predictors = Predictors_Quercus, main='glm')

#----------------------4c - Predictions for the current and future climate ----------------------#
#Current climate
glm_cur <- predict(object = Current_climate,
                   model = glm_model_Quercus,
                   type = "response",
                   na.rm = TRUE)
#Current climate
glm_proj <- predict(object = Future_climate, 
                    model = glm_model_Quercus, 
                    type = "response", 
                    na.rm = TRUE)

glm_chg <- c(glm_cur, glm_proj)
names(glm_chg) <- c("Current", "Future")

glm_clas <- ifel(glm_chg > perf_glm$thresh, 1, 0)
summary(glm_clas)

plot(glm_clas)




######################################################
###############  5- Model comparison   ###############
######################################################
# Below are the algorithms we fitted and the predictions we made on test data to asses our models performances
rf_Quercus
gbm_mod2_Quercus
gam_model_Quercus
glm_model_Quercus

# Predict on test set
(perf_glm_Quercus <- evalSDM(Quercus_test$presence_absence, predict(glm_model_Quercus, Quercus_test, type='response')))
(perf_gam_Quercus <- evalSDM(Quercus_test$presence_absence, predict(gam_model_Quercus, Quercus_test, type='response')))
(perf_rf_Quercus <- evalSDM(Quercus_test$presence_absence, predict(rf_Quercus, Quercus_test, type='response')))
(perf_gbm_Quercus <- evalSDM(Quercus_test$presence_absence, predict(gbm_mod2_Quercus, Quercus_test, type='response')))


#------  5a - Combine the performances of our models and compare them ------#
(comp_perf_Quercus <- rbind(glm_pred = perf_glm_Quercus,
                            gam_pred=perf_gam_Quercus,
                            rf_pred = perf_rf_Quercus,
                            gbm_pred = perf_gbm_Quercus))
# We add a column containing the names of the algorithm
comp_perf_Quercus <- data.frame(alg=row.names(comp_perf_Quercus),comp_perf_Quercus)

#------5b -combine all the Predictions we made on the test set ------#
pred_testdata_Quercus <- data.frame(
  glm_pred = predict(glm_model_Quercus, Quercus_test, type='response'),
  gam_pred=predict(gam_model_Quercus, Quercus_test, type='response'),
  rf_pred = predict(rf_Quercus, Quercus_test, type='response'),
  gbm_pred = predict(gbm_mod2_Quercus, Quercus_test, type='response'))

# Add it to the test set data
pred_testdata_Quercus <- cbind(pred_testdata_Quercus, Quercus_test)

#------ 5c - calculate the confusion matrix for each model and check model accuracy ------#
# Initialize an empty list to store confusion matrices
confusion_matrices_Quercus <- list()

# Iterate over the columns of pred_testdata_Quercus
for (col_name in names(pred_testdata_Quercus)) {
  # Skip columns that are not predictions
  if (!(col_name %in% c("glm_pred","gam_pred", "rf_pred", "gbm_pred"))) {
    next
  }
  
  # Calculate the confusion matrix for each prediction column
  predictions2 <- pred_testdata_Quercus
  threshold <- comp_perf_Quercus$thresh[match(col_name, comp_perf_Quercus$alg)]
  
  predictions2$pred <- ifelse(predictions2[[col_name]] > threshold, 1, 0)
  predictions2$pred <- as.factor(predictions2$pred)
  predictions2$presence_absence <- as.factor(predictions2$presence_absence)
  
  # Evaluate model performance on the test set
  confusion_matrices_Quercus[[col_name]] <- confusionMatrix(predictions2$pred, predictions2$presence_absence)
}

# Access confusion matrices for each prediction
# Example for accessing confusion matrix for glm_pred
confusion_matrices_Quercus$glm_pred$overall[1]
confusion_matrices_Quercus$gam_pred$overall[1]
confusion_matrices_Quercus$rf_pred$overall[1]
confusion_matrices_Quercus$gbm_pred$overall[1]



#----- 5d - plot AUC ROC -----#
roc_curve_glm<- roc(pred_testdata_Quercus$presence_absence, pred_testdata_Quercus$glm_pred)
roc_curve_gam<- roc(pred_testdata_Quercus$presence_absence, pred_testdata_Quercus$gam_pred)
roc_curve_rf<- roc(pred_testdata_Quercus$presence_absence, pred_testdata_Quercus$rf_pred)
roc_curve_gbm<- roc(pred_testdata_Quercus$presence_absence, pred_testdata_Quercus$gbm_pred)

# Combine TPR and FPR into a data frame
roc_curve_df <- rbind(
  data.frame(TPR = roc_curve_glm$sensitivities, FPR = 1 - roc_curve_glm$specificities, alg = "glm"),
  data.frame(TPR = roc_curve_gam$sensitivities, FPR = 1 - roc_curve_gam$specificities, alg = "gam"),
  data.frame(TPR = roc_curve_rf$sensitivities, FPR = 1 - roc_curve_rf$specificities, alg = "rf"),
  data.frame(TPR = roc_curve_gbm$sensitivities, FPR = 1 - roc_curve_gbm$specificities, alg = "gbm")
)

# Create a data frame for AUC values
auc_df <- data.frame(alg = c("glm", "gam", "rf", "gbm"),
                     AUC = c(roc_curve_glm$auc, roc_curve_gam$auc, roc_curve_rf$auc, roc_curve_gbm$auc))

# Plot ROC curves
ggplot(roc_curve_df, aes(x = FPR, y = TPR, color = alg)) +
  geom_line() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  labs(title = "ROC-AUC",
       x = "False Positive Rate (1 - Specificity)",
       y = "True Positive Rate (Sensitivity)",
       color = "Algorithm") +
  scale_x_continuous(expand = c(0.005, 0)) +
  scale_y_continuous(expand = c(0.005, 0)) +
  coord_fixed() +
  theme_bw() +
  facet_wrap(~ alg) +
  geom_text(data = auc_df, aes(x = 0.78, y = 0.2, label = paste0("AUC = ", round(AUC, 2))), size = 4, color = "black", fontface = "bold") + 
  theme(panel.spacing = unit(0.9, "cm", data = NULL))







#############################################
###############  6- Ensemble  ###############
#############################################
#------ 6a Predict the ensemble on the test data to get the thresholds and asses the performance of the ensemble ------#

crosspred_ens_Quercus <- data.frame(glm_pred=pred_testdata_Quercus$glm_pred,
                                    gam_pred=pred_testdata_Quercus$gam_pred,
                                    rf_pred=pred_testdata_Quercus$rf_pred ,
                                    gbm_pred=pred_testdata_Quercus$gbm_pred)

head(crosspred_ens_Quercus)
### Preparing the data for ensembles predictions ###
# Mean of probabilities
mean_prob_Quercus <- rowMeans(crosspred_ens_Quercus)
# Median of probabilities
median_prob_Quercus <- apply(crosspred_ens_Quercus, 1, median)
# Weighted mean of probabilities, weighted by TSS 
# (Make sure that order of models is the same in df for predictions and performance!!)
wmean_prob_Quercus <- apply(crosspred_ens_Quercus, 1, function(row) {
  weighted.mean(row, w = comp_perf_Quercus[row.names(comp_perf_Quercus), 'TSS'])
})

env_ensemble_Quercus <- data.frame(mean_prob_Quercus,median_prob_Quercus,wmean_prob_Quercus)

# performance measures for "mean of probabilities"
(perf_mean_prob_Quercus <- evalSDM(Quercus_test$presence_absence, mean_prob_Quercus))
# performance measures for "median of probabilities":
(perf_median_prob_Quercus <- evalSDM(Quercus_test$presence_absence, median_prob_Quercus))
# performance measures for "weighted mean of probabilities":
(perf_wmean_prob_Quercus <- evalSDM(Quercus_test$presence_absence, wmean_prob_Quercus))

# Compare performance measures:
(ens_perf_Quercus <- rbind(mean_prob = perf_mean_prob_Quercus,
                           median_prob = perf_median_prob_Quercus,
                           wmean_prob = perf_wmean_prob_Quercus))

# We add a column containing the names of the algorithm
ens_perf_Quercus <- data.frame(method=row.names(ens_perf_Quercus),ens_perf_Quercus)



#------ 6b Predict the ensemble to the current & future climate ------#

##################
# current climate:
##################
bio_curr_df_Quercus <- data.frame(rasterToPoints(Current_raster))
bio_curr_df_Quercus
bio_curr_df_Quercus<-na.omit(bio_curr_df_Quercus)

bio_curr_df_Quercus$pred_glm <- mecofun::predictSDM(glm_model_Quercus, bio_curr_df_Quercus)
bio_curr_df_Quercus$pred_gam <- mecofun::predictSDM(gam_model_Quercus, bio_curr_df_Quercus)
bio_curr_df_Quercus$pred_rf <- mecofun::predictSDM(rf_Quercus, bio_curr_df_Quercus)
bio_curr_df_Quercus$pred_gbm <- mecofun::predictSDM(gbm_mod2_Quercus,bio_curr_df_Quercus)
bio_curr_df_Quercus$pred_ens_mean <- apply(bio_curr_df_Quercus[,c(10:12)],1,mean)
bio_curr_df_Quercus$pred_ens_median <- apply(bio_curr_df_Quercus[,c(10:12)],1,median)
bio_curr_df_Quercus$pred_ens_wmean <- apply(bio_curr_df_Quercus[,c(10:13)],1, function(row) {
  weighted.mean(row, w = comp_perf_Quercus[row.names(comp_perf_Quercus), 'TSS'])
})


# Make binary predictions:
bio_curr_df_Quercus$bin_glm <- ifelse(bio_curr_df_Quercus$pred_glm > perf_glm_Quercus$thresh, 1, 0)
bio_curr_df_Quercus$bin_gam<- ifelse(bio_curr_df_Quercus$pred_gam > perf_gam_Quercus$thresh, 1, 0)
bio_curr_df_Quercus$bin_rf <- ifelse(bio_curr_df_Quercus$pred_rf > perf_rf_Quercus$thresh, 1, 0)
bio_curr_df_Quercus$bin_gbm <- ifelse(bio_curr_df_Quercus$pred_gbm > perf_gbm_Quercus$thresh, 1, 0)
bio_curr_df_Quercus$bin_ens_mean <- ifelse(bio_curr_df_Quercus$pred_ens_mean > ens_perf_Quercus[1,]$thresh, 1, 0)
bio_curr_df_Quercus$bin_ens_median <- ifelse(bio_curr_df_Quercus$pred_ens_median > ens_perf_Quercus[2,]$thresh, 1, 0)
bio_curr_df_Quercus$bin_ens_wmean <- ifelse(bio_curr_df_Quercus$pred_ens_wmean > ens_perf_Quercus[3,]$thresh, 1, 0)

head(bio_curr_df_Quercus)
# Make raster stack of predictions:
pred_curr_Quercus <- rasterFromXYZ(bio_curr_df_Quercus[,-c(3:9)])

##### Ensemble predictions mapping #####

plot(pred_curr_Quercus)

par(mfrow=c(2,5))

## Prob ##
plot(pred_curr_Quercus$pred_glm)
plot(pred_curr_Quercus$pred_gam)
plot(pred_curr_Quercus$pred_rf)
plot(pred_curr_Quercus$pred_gbm)
plot(pred_curr_Quercus$pred_ens_mean)

## Binary ##
plot(pred_curr_Quercus$bin_glm)
plot(pred_curr_Quercus$bin_gam)
plot(pred_curr_Quercus$bin_rf)
plot(pred_curr_Quercus$bin_gbm)
plot(pred_curr_Quercus$bin_ens_mean)

#################
# future climate:
#################
bio_fut_df_Quercus <- data.frame(rasterToPoints(Future_raster))
bio_fut_df_Quercus<-na.omit(bio_fut_df_Quercus)


bio_fut_df_Quercus$pred_glm <- mecofun::predictSDM(glm_model_Quercus, bio_fut_df_Quercus)
bio_fut_df_Quercus$pred_gam <- mecofun::predictSDM(gam_model_Quercus, bio_fut_df_Quercus)
bio_fut_df_Quercus$pred_rf <- mecofun::predictSDM(rf_Quercus, bio_fut_df_Quercus)
bio_fut_df_Quercus$pred_gbm <- mecofun::predictSDM(gbm_mod2_Quercus,bio_fut_df_Quercus)
bio_fut_df_Quercus$pred_ens_mean <- apply(bio_fut_df_Quercus[,c(10:12)],1,mean)
bio_fut_df_Quercus$pred_ens_median <- apply(bio_fut_df_Quercus[,c(10:12)],1,median)
bio_fut_df_Quercus$pred_ens_wmean <- apply(bio_fut_df_Quercus[,c(10:13)],1, function(row) {
  weighted.mean(row, w = comp_perf_Quercus[row.names(comp_perf_Quercus), 'TSS'])
})
head(bio_fut_df_Quercus)

# Make binary predictions:
bio_fut_df_Quercus$bin_glm <- ifelse(bio_fut_df_Quercus$pred_glm > perf_glm$thresh, 1, 0)
bio_fut_df_Quercus$bin_gam<- ifelse(bio_fut_df_Quercus$pred_gam > perf_gam$thresh, 1, 0)
bio_fut_df_Quercus$bin_rf <- ifelse(bio_fut_df_Quercus$pred_rf > perf_rf$thresh, 1, 0)
bio_fut_df_Quercus$bin_gbm <- ifelse(bio_fut_df_Quercus$pred_gbm > perf_gbm$thresh, 1, 0)
bio_fut_df_Quercus$bin_ens_mean <- ifelse(bio_fut_df_Quercus$pred_ens_mean > ens_perf[1,]$thresh, 1, 0)
bio_fut_df_Quercus$bin_ens_median <- ifelse(bio_fut_df_Quercus$pred_ens_median > ens_perf[2,]$thresh, 1, 0)
bio_fut_df_Quercus$bin_ens_wmean <- ifelse(bio_fut_df_Quercus$pred_ens_wmean > ens_perf[3,]$thresh, 1, 0)

head(bio_fut_df_Quercus)
# Make raster stack of predictions:
pred_fut_Quercus <- rasterFromXYZ(bio_fut_df_Quercus[,-c(3:9)])

##### Ensemble predictions mapping #####

plot(pred_fut_Quercus)

par(mfrow=c(2,5))
## Prob ##
plot(pred_fut_Quercus$pred_glm)
plot(pred_fut_Quercus$pred_gam)
plot(pred_fut_Quercus$pred_rf)
plot(pred_fut_Quercus$pred_gbm)
plot(pred_fut_Quercus$pred_ens_mean)

## Binary ##
plot(pred_fut_Quercus$bin_glm)
plot(pred_fut_Quercus$bin_gam)
plot(pred_fut_Quercus$bin_rf)
plot(pred_fut_Quercus$bin_gbm)
plot(pred_fut_Quercus$bin_ens_mean)